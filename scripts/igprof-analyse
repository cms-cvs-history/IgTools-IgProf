#!/usr/bin/env perl

BEGIN { use strict; $^W = 1; }

my $showlibs = 0;
my @keys;
my @allkeys;
my @sort;
my $order = 1;
my @filters;
my @filterfiles;
my $sortkey = "SELF_KEY";
my @builtinfilter = qw(malloc calloc realloc memalign posix_memalign valloc _Znwj _Znaj
		       _ZNSt24__default_alloc_templateILb1ELi0EE14_S_chunk_allocEjRi
		       _ZNSt24__default_alloc_templateILb1ELi0EE9_S_refillEj
		       _ZNSt24__default_alloc_templateILb1ELi0EE8allocateEj);

sub readDump
{
    my ($file) = @_;
    my $syms = {};
    my $nodes = { CHILDREN => [] };
    my $leaks = {};
    my $leaktable = undef;
    my @nodestack = ($nodes);

    open (DUMP, "< $file") || die "$file: $!\n";
    while (<DUMP>)
    {
        chomp;
	if (m|<sym addr="(.*)" offset="(.*)" name="(.*)" lib="(.*)"/>|)
	{
	    $syms->{$1}{OFFSET} = $2;
	    $syms->{$1}{NAME} = $3;
	    $syms->{$1}{LIB} = $4;
	}
	elsif (/(\s+)<node id="([^"]*)" symaddr="([^"]*)">/)
	{
	    my $node = { ID => $2, SYMADDR => $3, CHILDREN => [] };
	    $#nodestack = length($1)-2;
	    push (@{$nodestack[$#nodestack]{CHILDREN}}, $node);
	    push (@nodestack, $node);
	}
	elsif (/<counter name="(.*)" value="(.*)" count="(.*)"\/>/)
	{
	    $nodestack[$#nodestack]{COUNTERS}{$1} = [ $2, $3 ];
	}
	elsif (m|<live map="(.*)" size=".*">|)
	{
	    $leaktable = $1;
	}
	elsif (m|<leak node="(.*)" resource="(.*)" extra="(.*)"/>|)
	{
	    push(@{$leaks->{$leaktable}}, [ $1, $2, $3 ]);
	}
   }
   close (DUMP);
   return { SYMS => $syms, LEAKS => $leaks, NODES => [ $nodes ] };
}

sub keysof
{
    my ($dump) = @_;
    my @keys = ();
    foreach my $node (@{$dump->{NODES}}) {
	@keys = &checkkeys ($node, @keys);
    }
    return @keys;
}

sub checkkeys
{
    my ($node, @keys) = @_;
    foreach my $key (keys %{$node->{COUNTERS}}) {
	push (@keys, $key) if ! grep ($_ eq $key, @keys);
    }
    foreach my $kid (@{$node->{CHILDREN}}) {
	@keys = &checkkeys ($kid, @keys);
    }
    return @keys;
}

sub analyse
{
    my ($dump) = @_;

    $dump->{NODES}[0]{SYMADDR} = "-1";
    $dump->{SYMS}{"-1"} = { OFFSET => "", NAME => "<spontaneous>", LIB => "" };

    # Accumulate values
    foreach my $node (map { @{$_->{CHILDREN}} } @{$dump->{NODES}}) {
	&accumulate ($dump->{NODES}[0], $node);
    }

    # Suppress filtered symbols
    foreach my $node (map { @{$_->{CHILDREN}} } @{$dump->{NODES}}) {
	&suppressions ($dump->{SYMS}, $dump->{NODES}[0], $node);
    }

    # Initialise result table
    my $flat = {};
    foreach my $node (@{$dump->{NODES}}) {
	&analysenode (undef, $node, $flat);
    }

    # Calculate final sort keys
    foreach my $sym (keys %$flat) {
	&summarise ($flat, $sym);
    }

    # Sort the symbols by selected criteria
    my $rank = 1;
    my @keyorder = @sort;
    foreach my $key (@keys) {
	push (@keyorder, $key) if ! grep ($_ eq $key, @keyorder);
    }

    my @sorted = sort { &cmpnodes($flat, \@keyorder, $a, $b); } keys %$flat;
    foreach my $sym (@sorted) {
	$flat->{$sym}{RANK} = $rank++;
    }

    # Output result table
    print "keys = ", join (", ", @keyorder), "\n";
    foreach my $sym (@sorted) {
	# print parents
	print "\n", "-" x 78, "\n";
	foreach my $caller (sort keys %{$flat->{$sym}{CALLERS}})
	{
	    my $thiscall = $flat->{$caller}{CALLS}{$sym};
	    print "\t";
	    foreach my $key (@keyorder)
	    {
		print $flat->{$caller}{CUM_KEY}{$key}[0], "/", $thiscall->{$key}[0], "\t",
		      $flat->{$caller}{$sortkey}{$key}[1], "/", $thiscall->{$key}[1], "\t";
	    }
	    print "$dump->{SYMS}{$caller}{NAME} [$flat->{$caller}{RANK}]";
	    print " ($dump->{SYMS}{$caller}{LIB})" if $showlibs;
	    print "\n";
	}

	# print row
	print join("\t", "[$flat->{$sym}{RANK}]",
		   (map { (@{$flat->{$sym}{$sortkey}{$_}}) } @keyorder),
   		   "$dump->{SYMS}{$sym}{NAME}");
	print " ($dump->{SYMS}{$sym}{LIB})" if $showlibs;
	print "\n";

	# print children
	foreach my $callee (sort keys %{$flat->{$sym}{CALLS}})
	{
	    my $thiscall = $flat->{$sym}{CALLS}{$callee};
	    print "\t";
	    foreach my $key (@keyorder)
	    {
		print $flat->{$callee}{CUM_KEY}{$key}[0], "/", $thiscall->{$key}[0], "\t",
		      $flat->{$callee}{$sortkey}{$key}[1], "/", $thiscall->{$key}[1], "\t";
	    }
	    print "$dump->{SYMS}{$callee}{NAME} [$flat->{$callee}{RANK}]";
	    print " ($dump->{SYMS}{$callee}{LIB})" if $showlibs;
	    print "\n";
	}
    }
}

sub accumulate
{
    my ($parent, $node) = @_;

    # Initialise missing counters
    foreach my $counter (@allkeys)
    {
	$node->{COUNTERS}{$counter} = [ 0, 0 ]
	    if ! exists $node->{COUNTERS}{$counter};
    }

    # Initialise cumulative counters to self values
    foreach my $counter (keys %{$node->{COUNTERS}})
    {
	$counter =~ /([A-Z]+_)(.*)/;
	my $cumname = "$1CUM_$2";
	$node->{COUNTERS}{$cumname} = [ @{$node->{COUNTERS}{$counter}} ];
    }

    # Process children
    foreach my $kid (@{$node->{CHILDREN}}) {
	&accumulate ($node, $kid);
    }

    # Accumulate parent cumulative counts
    foreach my $counter (grep ($_ !~ /_CUM_/, keys %{$node->{COUNTERS}}))
    {
	$counter =~ /([A-Z]+_)(.*)/;
	my $cumname = "$1CUM_$2";
	my $cumval = $node->{COUNTERS}{$cumname};

	defined $cumval or die;
	$parent->{COUNTERS}{$counter} ||= [ 0, 0 ];
	$parent->{COUNTERS}{$cumname} ||= [ 0, 0 ];
	if ($counter =~ /_MAX$/)
	{
	    $parent->{COUNTERS}{$cumname}[0] = $cumval->[0]
	        if $parent->{COUNTERS}{$cumname}[0] < $cumval->[0];
	    $parent->{COUNTERS}{$cumname}[1] += $cumval->[1];
	}
	else
	{
	    $parent->{COUNTERS}{$cumname}[0] += $cumval->[0];
	    $parent->{COUNTERS}{$cumname}[1] += $cumval->[1];
        }
    }
}

sub suppressions
{
    my ($syms, $parent, $node) = @_;

    # Apply counts of a filtered node to the parent
    if (grep ($_ eq $syms->{$node->{SYMADDR}}{NAME}, @filters))
    {
        foreach my $counter (grep ($_ !~ /_CUM_/, keys %{$node->{COUNTERS}}))
	{
	    my $name = $counter;
	    $name =~ /([A-Z]+_)(.*)/;
	    $name = "$1$2";
	    my $cumname = "$1CUM_$2";
	    my $cumval = $node->{COUNTERS}{$cumname};

	    defined $cumval or die;
	    defined $parent->{COUNTERS}{$name} or die;
	    if ($name =~ /_MAX$/)
	    {
		$parent->{COUNTERS}{$name}[0] = $cumval->[0]
		    if $parent->{COUNTERS}{$name}[0] < $cumval->[0];
		$parent->{COUNTERS}{$name}[1] += $cumval->[1];
	    }
	    else
	    {
		$parent->{COUNTERS}{$name}[0] += $cumval->[0];
		$parent->{COUNTERS}{$name}[1] += $cumval->[1];
	    }
        }

	@{$parent->{CHILDREN}} = grep ($_ ne $node, @{$parent->{CHILDREN}});
    }

    # Process children
    my @kids = @{$node->{CHILDREN}};
    foreach my $kid (@kids) {
	&suppressions ($syms, $node, $kid);
    }
}

sub summarise 
{
    my ($flat, $sym) = @_;
    foreach my $key (@keys) {
	my ($sval, $cval);
	if ($key =~ /_MAX$/) {
	    $sval = $flat->{$sym}{SELF}{MAX}{$key};
	    $cval = $flat->{$sym}{CUM}{MAX}{$key};
	} else {
	    $sval = $flat->{$sym}{SELF}{SUM}{$key};
	    $cval = $flat->{$sym}{CUM}{SUM}{$key};
	}
	$flat->{$sym}{SELF_KEY}{$key} = [ @$sval ];
	$flat->{$sym}{CUM_KEY}{$key} = [ @$cval ];
    }

    return 0;
}

sub cmpnodekey
{
    my ($flat, $which, $keys, $a, $b) = @_;
    foreach my $key (@$keys) {
	my $aval = $flat->{$a}{$which}{$key}[0];
	my $bval = $flat->{$b}{$which}{$key}[0];
	$aval = -1 if ! defined ($aval);
	$bval = -1 if ! defined ($bval);
	my $diff = -1 * $order * ($aval <=> $bval);
	return $diff if $diff;
    }

    return 0;
}

sub callcheck
{
    # check if a calls b; return 1 if it does (= should come before)
    my ($flat, $a, $b, $seen) = @_;
    return 0 if $b eq $a;
    return 0 if exists $seen->{$b};
    foreach my $callee (keys %{$flat->{$a}{CALLS}}) {
	return -1 if $b eq $callee;
	return -1 if &callcheck ($flat, $callee, $b, $seen) < 0;
    }
    return 0;
}

sub cmpcallers
{
    my ($flat, $a, $b) = @_;
    # If a calls b, order it first
    my $acall = &callcheck ($flat, $a, $b, {});
    my $bcall = &callcheck ($flat, $b, $a, {});
    return $acall <=> $bcall;
}

sub cmpnodes
{
    my ($flat, $keys, $a, $b) = @_;
    return &cmpnodekey ($flat, $sortkey, $keys, $a, $b)
        || &cmpnodekey ($flat, "CUM_KEY", $keys, $a, $b)
	|| &cmpcallers ($flat, $a, $b)
	|| (eval ($a) <=> eval ($b));
}

sub analysenode
{
    my ($parent, $node, $result) = @_;
    my $sym = $node->{SYMADDR};
    my $symnode = ($result->{$sym} ||= {});

    # Add values for all requested counters.  Note that all counters exist.
    foreach my $counter (keys %{$node->{COUNTERS}}) {
	my ($part, $name, $val) = ("SELF", $counter, $node->{COUNTERS}{$counter});
	if ($name =~ /([A-Z]+_)CUM_(.*)/) {
	    $part = "CUM"; $name = "$1$2";
	}

	if (grep ($name eq $_, @keys))
	{
	    if ($parent)
	    {
	        $symnode->{CALLERS}{$parent} = 1;
		$result->{$parent}{CALLS}{$sym}{$counter} ||= [ 0, 0 ];
		$result->{$parent}{CALLS}{$sym}{$counter}[0] += $val->[0];
		$result->{$parent}{CALLS}{$sym}{$counter}[1]++;
	    }

            $symnode->{$part}{MAX}{$name} ||= [ 0, 0 ];
            $symnode->{$part}{MAX}{$name}[0] = $val->[0]
		if ($symnode->{$part}{MAX}{$name}[0] < $val->[0]);
            $symnode->{$part}{MAX}{$name}[1]++;

            $symnode->{$part}{SUM}{$name} ||= [ 0, 0 ];
            $symnode->{$part}{SUM}{$name}[0] += $val->[0];
            $symnode->{$part}{SUM}{$name}[1]++;
	}
    }

    # Analyse children
    foreach my $kid (@{$node->{CHILDREN}}) {
	&analysenode ($sym, $kid, $result);
    }
}

sub usage
{
    print STDERR "igprof-analyse [--report KEY[,KEY]...]\n",
    		 "  [--sort KEY[,KEY]...] [--order ORDER]\n",
		 "  [--filter FILE] [--no-filter] [--]\n",
		 "  [FILE]...\n";
}

while ($#ARGV != 0)
{
    if ($ARGV[0] eq '--help')
    { &usage(); exit (1); }
    elsif ($ARGV[0] eq '--report')
    { @keys = split(',', $ARGV[1]); shift (@ARGV); shift (@ARGV); }
    elsif ($ARGV[0] eq '--sort')
    { @sort = split(',', $ARGV[1]); shift (@ARGV); shift (@ARGV); }
    elsif ($ARGV[0] eq '--order')
    { $order = $ARGV[1] eq 'ascending' ? -1 : 1; shift (@ARGV); shift (@ARGV); }
    elsif ($ARGV[0] eq '--filter')
    { push (@filterfiles, $ARGV[1]); shift (@ARGV); shift (@ARGV); }
    elsif ($ARGV[0] eq '--no-filter')
    { @builtinfilter = (); shift (@ARGV); }
    elsif ($ARGV[0] eq '--self')
    { $sortkey = "SELF_KEY"; shift (@ARGV); }
    elsif ($ARGV[0] eq '--cumulative')
    { $sortkey = "CUM_KEY"; shift (@ARGV); }
    elsif ($ARGV[0] eq '--libs')
    { $showlibs = 1; shift (@ARGV); }
    elsif ($ARGV[0] eq '--')
    { last; }
    elsif ($ARGV[0] =~ /^-/)
    { print STDERR "unknown option $ARGV[0]"; &usage(); exit (1); }
    else
    { last; }
}

# read in lists of filter symbols
@filters = @builtinfilter;
foreach my $file (@filterfiles)
{
    open (FILTER, "< $file") || die "$file: $!\n";
    while (<FILTER>)
    {
  	chomp;
	push (@filters, split(/s+/, $_));
    }
    close (FILTER);
}

foreach my $file (@ARGV)
{
    my $prof = &readDump ($file);
    @allkeys = &keysof ($prof);
    @keys = @allkeys if ! scalar @keys;
    &analyse ($prof);
}
