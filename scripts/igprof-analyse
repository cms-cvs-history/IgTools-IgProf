#!/usr/bin/env perl

BEGIN { use strict; use warnings; $^W = 1; }

my $output = "text";
my $demangle = 0;
my $gdb = 0;
my $showlibs = 0;
my $verbose = 0;
my $key;
my @allkeys;
my $order = 1;
my @filters;
my @filterfiles;
my $sortkey = "SELF_KEY";
my @builtinfilter = qw(malloc calloc realloc memalign posix_memalign valloc _Znwj _Znaj
		       _ZNSt24__default_alloc_templateILb1ELi0EE14_S_chunk_allocEjRi
		       _ZNSt24__default_alloc_templateILb1ELi0EE9_S_refillEj
		       _ZNSt24__default_alloc_templateILb1ELi0EE8allocateEj);


my %demangled = ();
sub symname
{
    my ($sym, $lib, $liboffset) = @_;
    my $suffix = "";
    if ($sym =~ /(.*)('[0-9]+)/o)
    {
	$sym = $1;
	$suffix = $2;
    }

    if (! exists $demangled{$sym}) {
	my $new = $sym;
	if ($gdb && $lib)
	{
	    # use gdb to figure out real symbol
	    my $file = "/tmp/igprof-analyse.$$";
	    open (TMP, "> $file") || die;
	    print TMP "file $lib\n";
	    print TMP "info line *$liboffset\n";
	    close (TMP) || die;

	    open (GDB, "gdb --batch --command=$file |") || die;
	    while (<GDB>)
	    {
		if (/starts at .* <([A-Za-z0-9_]+)(\+\d+)?>/) {
		    $new = $1; last;
		} elsif (/^No line number .* <([A-Za-z0-9_]+)(\+\d+)?>/) {
		    $new = $1; last;
	        }
	    }
	    close (GDB);
	    unlink ($file);
	}
	
	if ($demangle) {
	    # now demangle if requested
	    chomp ($new = `c++filt '$new'`);
	}
	$demangled{$sym} = $new;
    }

    return $demangled{$sym} . $suffix;
}

sub readDump
{
    my ($file) = @_;
    my $syms = {};
    my $nodes = { CHILDREN => [] };
    my $leaks = {};
    my $leaktable = undef;
    my @nodestack = ($nodes);

    open (DUMP, "< $file") || die "$file: $!\n";
    while (<DUMP>)
    {
        chomp;
	if (m|<sym addr="(.*)" offset="(.*)" name="(.*)" lib="(.*)" liboff="(.*)"/>|)
	{
	    $syms->{$1}{OFFSET} = $2;
	    $syms->{$1}{NAME} = $3;
	    $syms->{$1}{LIB} = $4;
	    $syms->{$1}{LIBOFF} = $5;
	}
	elsif (m|<sym addr="(.*)" offset="(.*)" name="(.*)" lib="(.*)"/>|)
	{
	    $syms->{$1}{OFFSET} = $2;
	    $syms->{$1}{NAME} = $3;
	    $syms->{$1}{LIB} = $4;
	    $syms->{$1}{LIBOFF} = 0;
	}
	elsif (/(\s+)<node id="([^"]*)" symaddr="([^"]*)">/)
	{
	    my $node = { ID => $2, SYMADDR => $3, CHILDREN => [] };
	    $#nodestack = length($1)-2;
	    push (@{$nodestack[$#nodestack]{CHILDREN}}, $node);
	    push (@nodestack, $node);
	}
	elsif (/<counter name="(.*)" value="(.*)" count="(.*)"\/>/)
	{
	    $nodestack[$#nodestack]{COUNTERS}{$1} = [ $2, $3 ];
	}
	elsif (m|<live map="(.*)" size=".*">|)
	{
	    $leaktable = $1;
	}
	elsif (m|<leak node="(.*)" resource="(.*)" extra="(.*)"/>|)
	{
	    push(@{$leaks->{$leaktable}}, [ $1, $2, $3 ]);
	}
   }
   close (DUMP);
   return { SYMS => $syms, LEAKS => $leaks, NODES => [ $nodes ] };
}

sub walk
{
    my ($args, $pre, $post, @nodes) = @_;
    my @stack = map { [ $_, undef ] } @nodes;
    while (@stack)
    {
	my ($node_pre, $node_post) = @{pop(@stack)};
	if ($node_pre)
	{
	    &$pre($node_pre, @$args) if defined $pre;
	    push(@stack, [ undef, $node_pre ]) if $post;
	    push(@stack, map { [ $_, undef ] } @{$$node_pre{CHILDREN}});
	}
	else
	{
	    &$post($node_post, @$args);
	}
    }
}

sub keysof
{
    my ($dump) = @_;
    my %keys = ();
    &walk([ \%keys ],
	  sub { my ($node, $keys) = @_;
		$$keys{$_} ||= 1 for keys %{$$node{COUNTERS}} },
	  undef,
	  @{$$dump{NODES}});
    return keys %keys;
}

sub symfor
{
    my ($dump, $seen, $node) = @_;
    if ($$node{REPORT_SYMADDR})
    {
	$$seen{$$node{REPORT_SYMADDR}} = 1;
	return ($$node{SYMADDR}, $$node{REPORT_SYMADDR});
    }

    my $suffix = "";
    my $sym = $$node{SYMADDR};
    if (exists $$seen{$sym})
    {
	$sym =~ s/'[0-9]+$//;
	my $index = 2;
        $index++ while exists $$seen{"$sym'$index"};
	$suffix = "'$index";
	if (! exists $$dump{SYMS}{"$sym$suffix"})
	{
            $$dump{SYMS}{"$sym$suffix"} = { %{$$dump{SYMS}{$sym}} };
            $$dump{SYMS}{"$sym$suffix"}{NAME} =~ s/'[0-9]+$//;
            $$dump{SYMS}{"$sym$suffix"}{NAME} .= $suffix;
	}
    }
    $$node{REPORT_SYMADDR} = "$sym$suffix";
    $$seen{"$sym$suffix"} = 1;
    return ($sym, "$sym$suffix");
}

sub analyse
{
    my ($dump) = @_;

    $$_{SYMADDR} = "-1" for @{$$dump{NODES}};
    $$dump{SYMS}{"-1"} = { OFFSET => "", NAME => "<spontaneous>", LIB => "" };

    # Accumulate values.  Initialise all counters in all nodes, then
    # propagate children's counts to the parent cumulative counts.
    do { local $|=1; print "Summing counters: " } if $verbose;
    &walk([],
	  sub { my ($node) = @_;
	        $$node{COUNTERS}{$key} ||= [ 0, 0 ];
		$$node{COUNTERS}{$key . "_CUM"} = [ @{$$node{COUNTERS}{$key}} ]; },
	  sub { my ($node) = @_;
                do { local $|=1; print "." } if $verbose;
		my $cumkey = "${key}_CUM";
		my $cumval = $$node{COUNTERS}{$cumkey};
		defined $cumval or die;

		foreach my $kid (@{$$node{CHILDREN}})
		{
		    defined $$kid{COUNTERS}{$cumkey} or die;
		    if ($key =~ /_MAX$/o)
		    {
			$$cumval[0] = $$kid{COUNTERS}{$cumkey}[0]
			    if $$cumval[0] < $$kid{COUNTERS}{$cumkey}[0];
			$$cumval[1] += $$kid{COUNTERS}{$cumkey}[1];
		    }
		    else
		    {
			$$cumval[0] += $$kid{COUNTERS}{$cumkey}[0];
			$$cumval[1] += $$kid{COUNTERS}{$cumkey}[1];
		    }
		} },
	  @{$$dump{NODES}});
    print "\n" if $verbose;

    # Suppress filtered symbols: apply counts of filtered
    # nodes to the self-counts of the parent.
    do { local $|=1; print "Suppressing symbols: " } if $verbose;
    &walk([ $$dump{SYMS} ],
	  sub { my ($node, $syms) = @_;
                do { local $|=1; print "." } if $verbose;
		my $kids = $$node{CHILDREN};
		$$node{CHILDREN} = [];
		foreach my $kid (@$kids)
		{
		    if (! grep($_ eq $$syms{$$kid{SYMADDR}}{NAME}, @filters))
		    {
			push(@{$$node{CHILDREN}}, $kid);
			next;
		    }

		    my $cumkey = "${key}_CUM";
		    my $val = $$node{COUNTERS}{$key};

		    defined $val or die;
		    defined $$kid{COUNTERS}{$key} or die;
		    defined $$kid{COUNTERS}{$cumkey} or die;

		    if ($key =~ /_MAX$/o)
		    {
			$$val[0] = $$kid{COUNTERS}{$cumkey}[0]
			    if $$kid{COUNTERS}{$cumkey}[0] > $$val[0];
			$$val[1] += $$kid{COUNTERS}{$cumkey}[1];
		    }
		    else
		    {
			$$val[0] += $$kid{COUNTERS}{$cumkey}[0];
			$$val[1] += $$kid{COUNTERS}{$cumkey}[1];
		    }
		} },
	  undef,
	  @{$$dump{NODES}});
    print "\n" if $verbose;

    # Initialise result table.  Add values for all requested counters.
    # Note that all counters are already initialised in every node.
    do { local $|=1; print "Flattening: " } if $verbose;
    my $flat = {};
    my $calls = {};
    my $seen = {};
    &walk([ $dump, $flat, $calls, $seen ],
	  sub { my ($node, $dump, $flat, $calls, $seen) = @_;
                do { local $|=1; print "." } if $verbose;
	        my ($realsym, $sym) = &symfor($dump, $seen, $node);
		my $symnode = ($$flat{$sym} ||= {});
	        foreach my $counter ($key, "${key}_CUM")
		{
		    my ($part, $name, $val) = ("SELF", $counter, $$node{COUNTERS}{$counter});
		    if ($name =~ /(.*)_CUM$/) {
			$part = "CUM"; $name = "$1";
		    }

		    next if $name ne $key;

		    foreach my $kid (@{$$node{CHILDREN}})
		    {
			my ($kidrealsym, $kidsym) = &symfor($dump, $seen, $kid);
			my $kidsymnode = ($$flat{$kidsym} ||= {});
			my $kidval = $$kid{COUNTERS}{$counter};
			$$kidsymnode{CALLERS}{$sym} = 1;
			$$symnode{CALLS}{$kidsym}{$counter} ||= [ 0, 0 ];
			$$symnode{CALLS}{$kidsym}{$counter}[0] += $$kidval[0];
			$$symnode{CALLS}{$kidsym}{$counter}[1]++;
			$$calls{$sym}{$kidsym} = 1;
			delete $$kid{$kidsym};
			delete $$seen{$kidsym};
		    }

		    $$symnode{$part}{MAX}{$name} ||= [ 0, 0 ];
		    $$symnode{$part}{MAX}{$name}[0] = $$val[0]
			if ($$symnode{$part}{MAX}{$name}[0] < $$val[0]);
		    $$symnode{$part}{MAX}{$name}[1]++;
	    
		    $$symnode{$part}{SUM}{$name} ||= [ 0, 0 ];
		    $$symnode{$part}{SUM}{$name}[0] += $$val[0];
		    $$symnode{$part}{SUM}{$name}[1]++;
		} },
	  sub { my ($node, $dump, $flat, $calls, $seen) = @_;
		my $sym = $$node{REPORT_SYMADDR};
		delete $$seen{$sym};
		foreach my $kid (@{$$node{CHILDREN}})
		{
		    my $kidsym = $$kid{REPORT_SYMADDR};
		    next if ! exists $$calls{$kidsym};
		    $$calls{$sym}{$_} = 1 for keys %{$$calls{$kidsym}};
		} },
	  @{$$dump{NODES}});
    print "\n" if $verbose;

    # Calculate final sort keys
    do { local $|=1; print "Summarising: " } if $verbose;
    foreach my $sym (keys %$flat)
    {
        do { local $|=1; print "." } if $verbose;
	my ($sval, $cval);
	if ($key =~ /_MAX$/)
	{
	    $sval = $$flat{$sym}{SELF}{MAX}{$key};
	    $cval = $$flat{$sym}{CUM}{MAX}{$key};
	}
	else
	{
	    $sval = $$flat{$sym}{SELF}{SUM}{$key};
	    $cval = $$flat{$sym}{CUM}{SUM}{$key};
	}
	$$flat{$sym}{SELF_KEY}{$key} = [ @$sval ];
	$$flat{$sym}{CUM_KEY}{$key} = [ @$cval ];
    }
    print "\n" if $verbose;

    # Sort the symbols by selected criteria
    do { local $|=1; print "Sorting\n" } if $verbose;
    my $rank = 1;
    my @sorted = sort { &cmpnodes($flat, $calls, $a, $b); } keys %$flat;
    foreach my $sym (@sorted) {
	$$flat{$sym}{RANK} = $rank++;
    }

    # Output result table
    do { local $|=1; print "Generating report\n" } if $verbose;
    my @table = ();
    foreach my $sym (@sorted) {
	my $row = { CALLERS => [], SYM => [], CALLS => [] };
	push (@table, $row);

	my @parents = sort { ($sortkey eq "SELF_KEY"
			      ? ($flat->{$a}{CALLS}{$sym}{$key}[0]
			         <=> $flat->{$b}{CALLS}{$sym}{$key}[0])
			      : 0)
			     || ($flat->{$a}{CUM_KEY}{$key}[0]
			         <=> $flat->{$b}{CUM_KEY}{$key}[0]) }
	    sort keys %{$flat->{$sym}{CALLERS}};

	my @children = sort { ($sortkey eq "SELF_KEY"
			       ?  ($flat->{$sym}{CALLS}{$b}{$key}[0]
			           <=> $flat->{$sym}{CALLS}{$a}{$key}[0])
			       : 0)
			      || ($flat->{$b}{CUM_KEY}{$key}[0]
			          <=> $flat->{$a}{CUM_KEY}{$key}[0]) }
	    sort keys %{$flat->{$sym}{CALLS}};

	# parents
	foreach my $caller (@parents)
	{
	    my $thiscall = $flat->{$caller}{CALLS}{$sym};
	    my $callrow = [ $flat->{$caller}{RANK},
			    $dump->{SYMS}{$caller}{NAME},
			    $dump->{SYMS}{$caller}{LIB},
			    $dump->{SYMS}{$caller}{LIBOFF},
		            [ [ $flat->{$caller}{CUM_KEY}{$key}[0], $thiscall->{$key}[0] ],
			      [ $flat->{$caller}{$sortkey}{$key}[1], $thiscall->{$key}[1] ] ] ];
	    push (@{$row->{CALLERS}}, $callrow);
	}

	# row
	push (@{$row->{SYM}}, $flat->{$sym}{RANK});
	push (@{$row->{SYM}}, $dump->{SYMS}{$sym}{NAME});
	push (@{$row->{SYM}}, $dump->{SYMS}{$sym}{LIB});
	push (@{$row->{SYM}}, $dump->{SYMS}{$sym}{LIBOFF});
	push (@{$row->{SYM}}, $flat->{$sym}{$sortkey}{$key});

	# children
	foreach my $callee (@children)
	{
	    my $thiscall = $flat->{$sym}{CALLS}{$callee};
	    my $callrow = [ $flat->{$callee}{RANK},
			    $dump->{SYMS}{$callee}{NAME},
			    $dump->{SYMS}{$callee}{LIB},
			    $dump->{SYMS}{$callee}{LIBOFF},
		            [ [ $flat->{$callee}{CUM_KEY}{$key}[0], $thiscall->{$key}[0] ],
			      [ $flat->{$callee}{$sortkey}{$key}[1], $thiscall->{$key}[1] ] ] ];
	    push (@{$row->{CALLS}}, $callrow);
	}
    }

    if ($output eq 'text')
    {
        print "counter: $key\n";
	foreach my $entry (@table)
	{
	    my ($rank, $name, $lib, $val);
	    print "\n", "-" x 70, "\n";
	    foreach my $caller (@{$entry->{CALLERS}})
	    {
		($rank, $name, $lib, $liboff, $val) = @$caller;
		print join("\t", "", map { "$_->[0]/$_->[1]" } @$val);
		print "\t@{[&symname ($name, $lib, $liboff)]} [$rank]";
		print " ($lib)" if $showlibs;
		print "\n";
	    }

	    ($rank, $name, $lib, $liboff, $val) = @{$entry->{SYM}};
	    print join("\t", "[$rank]", @$val);
	    print "\t@{[&symname ($name, $lib, $liboff)]}";
	    print " ($lib)" if $showlibs;
	    print "\n";

	    foreach my $callee (@{$entry->{CALLS}})
	    {
		($rank, $name, $lib, $liboff, $val) = @$callee;
		print join("\t", "", map { "$_->[0]/$_->[1]" } @$val);
		print "\t@{[&symname ($name, $lib, $liboff)]} [$rank]";
		print " ($lib)" if $showlibs;
		print "\n";
	    }
	}
    }
    elsif ($output eq 'html')
    {
	sub htmlcounter {
	    my ($span, $value, $count) = @_;
	    my $spanarg = $span == 1 ? "" : " colspan=\"$span\"";
	    print "    <td$spanarg>$value</td>\n";
	    print "    <td$spanarg>$count</td>\n";
	}
	    
	sub htmlrow {
	    my ($type, $rank, $name, $lib, $liboff, $val) = @_;
	    print "  <tr>\n";
	    if ($type eq 0) {
		print "    <td><a name=\"R$rank\">[$rank]</a></td>\n";
	    } else {
		print "    <td>&nbsp;</td>\n";
	    }
	    if (ref($val) eq 'ARRAY' and ref($val->[0]) eq 'ARRAY') {
		# caller/call syntax
		&htmlcounter (1, $val->[0][0], $val->[1][0]);
		&htmlcounter (1, $val->[0][1], $val->[1][1]);
	    } else {
		# symbol syntax
		&htmlcounter (2, @$val);
	    }
	    $name = &symname ($name, $lib, $liboff);
	    $name =~ s/&/&amp;/g; $name =~ s/</&lt;/g; $name =~ s/>/&gt;/g;
	    print "    <td><a href=\"#R$rank\">$name</a>";
	    if ($type eq 0) {
		print "</td>\n";
	    } else {
		print "&nbsp;[$rank]</td>\n";
	    }
	    $lib =~ s/&/&amp;/g; $lib =~ s/</&lt;/g; $lib =~ s/>/&gt;/g;
	    print "    <td>$lib</td>\n" if $showlibs;
	    print "    <td>&nbsp;</td>\n" if ! $showlibs;
	    print "  </tr>\n";
	}

        print "<table width='100%' border='0'>\n";
	print "  <tr>\n";
	print "    <th>Order</th>\n";
	print "    <th colspan='4'>$key</td>\n";
	print "    <th>Symbol</th>\n";
	print "    <th>Library</th>\n";
	print "  </tr>\n";

	foreach my $entry (@table)
	{
	    print "  <tr><td colspan='7'><hr /></tr>\n";
	    foreach my $caller (@{$entry->{CALLERS}}) {
		&htmlrow (1, @$caller);
	    }

	    my $rank = $entry->{SYM}[0];
	    &htmlrow (0, @{$entry->{SYM}});

	    foreach my $callee (@{$entry->{CALLS}}) {
		&htmlrow (1, @$callee);
	    }
	}
        print "</table>\n";
    }
    elsif ($output eq 'xml')
    {
	sub xmlcounter {
	    my ($prefix, $type, $key, $value, $count) = @_;
	    print "    $prefix<value type=\"$type\" counter=\"$key\" ",
		  "value=\"$value\" count=\"$count\"/>\n";
	}
	    
	sub xmlrow {
	    my ($prefix, $rank, $name, $lib, $val) = @_;
	    my $keytype = $sortkey eq 'CUM_KEY' ? "cumulative" : "self";
	    print "  $prefix<entry rank=\"$rank\" symbol=\"$name\" module=\"$lib\">\n";
	    if (ref($val) eq 'ARRAY' and ref($val->[0]) eq 'ARRAY') {
		# caller/call syntax
		&xmlcounter ($prefix, "cumulative", $key, $val->[0][0], $val->[1][0]);
		&xmlcounter ($prefix, "call$keytype", $key, $val->[0][1], $val->[1][1]);
	    } else {
		# symbol syntax
		&xmlcounter ($prefix, $keytype, $key, @$val);
	    }
	}

        print "<igprof-analysis>\n";
	print "  <counter name=\"$key\"/>\n";
	foreach my $entry (@table)
	{
	    &xmlrow ("", @{$entry->{SYM}});
	    foreach my $caller (@{$entry->{CALLERS}}) {
		&xmlrow ("  ", @$caller);
	        print "       </entry>\n";
	    }
	    foreach my $callee (@{$entry->{CALLS}}) {
		&xmlrow ("  ", @$callee);
	        print "       </entry>\n";
	    }
	    print "   </entry>\n";
	}
        print "</igprof-analysis>\n";
    }
}

sub cmpnodekey
{
    my ($flat, $sortkey, $a, $b) = @_;
    my $aval = $$flat{$a}{$sortkey}{$key}[0];
    my $bval = $$flat{$b}{$sortkey}{$key}[0];
    $aval = -1 if ! defined ($aval);
    $bval = -1 if ! defined ($bval);
    my $diff = -1 * $order * ($aval <=> $bval);
    return $diff;
}

sub cmpcallers
{
    my ($flat, $calls, $a, $b) = @_;
    # If a calls b, order it first
    my $acall = (exists $$calls{$a} && exists $$calls{$a}{$b} ? -1 : 1);
    my $bcall = (exists $$calls{$b} && exists $$calls{$b}{$a} ? -1 : 1);
    return $acall <=> $bcall;
}

sub cmpnodes
{
    my ($flat, $calls, $a, $b) = @_;
    my $cmp = &cmpnodekey($flat, $sortkey, $a, $b);
    return $cmp if $cmp;

    if ($sortkey ne 'CUM_KEY')
    {
	$cmp = &cmpnodekey($flat, 'CUM_KEY', $a, $b);
	return $cmp if $cmp;
    }

    $cmp = &cmpcallers($flat, $calls, $a, $b);
    return $cmp if $cmp;
    return $a cmp $b;
}

sub usage
{
    print STDERR "igprof-analyse\n",
		 "  [-r/--report KEY[,KEY]...] [-o/--order ORDER]\n",
		 "  [-f/--filter FILE] [-F/--no-filter]\n",
		 "  { [-e/--self] | [-c/--cumulative] }\n",
		 "  { [-x/--xml] | [-h/--html] | [-t/--text] }\n",
		 "  [--libs] [--demangle] [--gdb] [-v/--verbose]\n",
		 "  [--] [FILE]...\n";
}

while (scalar @ARGV)
{
    if ($ARGV[0] eq '--help')
    { &usage(); exit (1); }
    elsif ($ARGV[0] eq '--verbose' || $ARGV[0] eq '-v')
    { $verbose = 1; shift(@ARGV); }
    elsif ($ARGV[0] eq '--report' || $ARGV[0] eq '-r')
    { shift(@ARGV); $key = shift(@ARGV); }
    elsif ($ARGV[0] eq '--order' || $ARGV[0] eq '-o')
    { $order = $ARGV[1] eq 'ascending' ? -1 : 1; shift (@ARGV); shift (@ARGV); }
    elsif ($ARGV[0] eq '--filter' || $ARGV[0] eq '-f')
    { push (@filterfiles, $ARGV[1]); shift (@ARGV); shift (@ARGV); }
    elsif ($ARGV[0] eq '--no-filter' || $ARGV[0] eq '-F')
    { @builtinfilter = (); shift (@ARGV); }
    elsif ($ARGV[0] eq '--self' || $ARGV[0] eq '-e')
    { $sortkey = "SELF_KEY"; shift (@ARGV); }
    elsif ($ARGV[0] eq '--cumulative' || $ARGV[0] eq '-c')
    { $sortkey = "CUM_KEY"; shift (@ARGV); }
    elsif ($ARGV[0] eq '--libs' || $ARGV[0] eq '-l')
    { $showlibs = 1; shift (@ARGV); }
    elsif ($ARGV[0] eq '--xml' || $ARGV[0] eq '-x')
    { $output = "xml"; shift (@ARGV); }
    elsif ($ARGV[0] eq '--html' || $ARGV[0] eq '-h')
    { $output = "html"; shift (@ARGV); }
    elsif ($ARGV[0] eq '--text' || $ARGV[0] eq '-t')
    { $output = "text"; shift (@ARGV); }
    elsif ($ARGV[0] eq '--demangle' || $ARGV[0] eq '-d')
    { $demangle = 1; shift (@ARGV); }
    elsif ($ARGV[0] eq '--gdb' || $ARGV[0] eq '-g')
    { $gdb = 1; shift (@ARGV); }
    elsif ($ARGV[0] eq '--')
    { last; }
    elsif ($ARGV[0] =~ /^-/)
    { print STDERR "unknown option $ARGV[0]"; &usage(); exit (1); }
    else
    { last; }
}

# read in lists of filter symbols
@filters = @builtinfilter;
foreach my $file (@filterfiles)
{
    open (FILTER, "< $file") || die "$file: $!\n";
    while (<FILTER>)
    {
  	chomp;
	push (@filters, split(/s+/, $_));
    }
    close (FILTER);
}

foreach my $file (@ARGV)
{
    my $prof = &readDump ($file);
    @allkeys = &keysof ($prof);
    die "Dump has no value for any counter\n" if ! @allkeys;
    if (! defined $key)
    {
	if (grep($_ eq 'PERF_TICKS', @allkeys))
	{
	    $key = 'PERF_TICKS';
	}
	elsif (grep($_ eq 'MEM_LIVE', @allkeys))
	{
	    $key = 'MEM_LIVE';
	}
	else
	{
	    $key = $allkeys[0];
	}
    }
    &analyse ($prof);
}
