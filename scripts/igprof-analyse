#!/usr/bin/env perl

BEGIN { use strict; $^W = 1; }

my $output = "text";
my $demangle = 0;
my $showlibs = 0;
my @keys;
my @allkeys;
my @sort;
my $order = 1;
my @filters;
my @filterfiles;
my $sortkey = "SELF_KEY";
my @builtinfilter = qw(malloc calloc realloc memalign posix_memalign valloc _Znwj _Znaj
		       _ZNSt24__default_alloc_templateILb1ELi0EE14_S_chunk_allocEjRi
		       _ZNSt24__default_alloc_templateILb1ELi0EE9_S_refillEj
		       _ZNSt24__default_alloc_templateILb1ELi0EE8allocateEj);


my %demangled = ();
sub symname
{
    my $sym = shift;
    if (! exists $demangled{$sym}) {
	my $new = $sym;
	if ($demangle) {
	    chomp ($new = `c++filt '$sym'`);
	}
	$demangled{$sym} = $new;
    }

    return $demangled{$sym};
}

sub readDump
{
    my ($file) = @_;
    my $syms = {};
    my $nodes = { CHILDREN => [] };
    my $leaks = {};
    my $leaktable = undef;
    my @nodestack = ($nodes);

    open (DUMP, "< $file") || die "$file: $!\n";
    while (<DUMP>)
    {
        chomp;
	if (m|<sym addr="(.*)" offset="(.*)" name="(.*)" lib="(.*)"/>|)
	{
	    $syms->{$1}{OFFSET} = $2;
	    $syms->{$1}{NAME} = $3;
	    $syms->{$1}{LIB} = $4;
	}
	elsif (/(\s+)<node id="([^"]*)" symaddr="([^"]*)">/)
	{
	    my $node = { ID => $2, SYMADDR => $3, CHILDREN => [] };
	    $#nodestack = length($1)-2;
	    push (@{$nodestack[$#nodestack]{CHILDREN}}, $node);
	    push (@nodestack, $node);
	}
	elsif (/<counter name="(.*)" value="(.*)" count="(.*)"\/>/)
	{
	    $nodestack[$#nodestack]{COUNTERS}{$1} = [ $2, $3 ];
	}
	elsif (m|<live map="(.*)" size=".*">|)
	{
	    $leaktable = $1;
	}
	elsif (m|<leak node="(.*)" resource="(.*)" extra="(.*)"/>|)
	{
	    push(@{$leaks->{$leaktable}}, [ $1, $2, $3 ]);
	}
   }
   close (DUMP);
   return { SYMS => $syms, LEAKS => $leaks, NODES => [ $nodes ] };
}

sub keysof
{
    my ($dump) = @_;
    my @keys = ();
    foreach my $node (@{$dump->{NODES}}) {
	@keys = &checkkeys ($node, @keys);
    }
    return @keys;
}

sub checkkeys
{
    my ($node, @keys) = @_;
    foreach my $key (keys %{$node->{COUNTERS}}) {
	push (@keys, $key) if ! grep ($_ eq $key, @keys);
    }
    foreach my $kid (@{$node->{CHILDREN}}) {
	@keys = &checkkeys ($kid, @keys);
    }
    return @keys;
}

sub analyse
{
    my ($dump) = @_;

    $dump->{NODES}[0]{SYMADDR} = "-1";
    $dump->{SYMS}{"-1"} = { OFFSET => "", NAME => "<spontaneous>", LIB => "" };

    # Accumulate values
    foreach my $node (map { @{$_->{CHILDREN}} } @{$dump->{NODES}}) {
	&accumulate ($dump->{NODES}[0], $node);
    }

    # Suppress filtered symbols
    foreach my $node (map { @{$_->{CHILDREN}} } @{$dump->{NODES}}) {
	&suppressions ($dump->{SYMS}, $dump->{NODES}[0], $node);
    }

    # Initialise result table
    my $flat = {};
    foreach my $node (@{$dump->{NODES}}) {
	&analysenode (undef, $node, $flat);
    }

    # Calculate final sort keys
    foreach my $sym (keys %$flat) {
	&summarise ($flat, $sym);
    }

    # Sort the symbols by selected criteria
    my $rank = 1;
    my @keyorder = @sort;
    foreach my $key (@keys) {
	push (@keyorder, $key) if ! grep ($_ eq $key, @keyorder);
    }

    my @sorted = sort { &cmpnodes($flat, \@keyorder, $a, $b); } keys %$flat;
    foreach my $sym (@sorted) {
	$flat->{$sym}{RANK} = $rank++;
    }

    # Output result table
    my @table = ();
    foreach my $sym (@sorted) {
	my $row = { CALLERS => [], SYM => [], CALLS => [] };
	push (@table, $row);

	my @parents = sort keys %{$flat->{$sym}{CALLERS}};
	my @children = sort keys %{$flat->{$sym}{CALLS}};
	if (scalar @keyorder == 1)
	{
	    @parents = sort { ($sortkey eq "SELF_KEY"
			       ? ($flat->{$a}{CALLS}{$sym}{$keyorder[0]}[0]
			          <=> $flat->{$b}{CALLS}{$sym}{$keyorder[0]}[0])
			       : 0)
			      || ($flat->{$a}{CUM_KEY}{$keyorder[0]}[0]
			          <=> $flat->{$b}{CUM_KEY}{$keyorder[0]}[0]) }
			@parents;

	    @children = sort { ($sortkey eq "SELF_KEY"
				?  ($flat->{$sym}{CALLS}{$b}{$keyorder[0]}[0]
			            <=> $flat->{$sym}{CALLS}{$a}{$keyorder[0]}[0])
				: 0)
			       || ($flat->{$b}{CUM_KEY}{$keyorder[0]}[0]
			           <=> $flat->{$a}{CUM_KEY}{$keyorder[0]}[0]) }
			@children;
	}

	# parents
	foreach my $caller (@parents)
	{
	    my $thiscall = $flat->{$caller}{CALLS}{$sym};
	    my $callrow = [ $flat->{$caller}{RANK},
			    $dump->{SYMS}{$caller}{NAME},
			    $dump->{SYMS}{$caller}{LIB} ];
	    foreach my $key (@keyorder)
	    {
		push (@$callrow,
		      [ [ $flat->{$caller}{CUM_KEY}{$key}[0], $thiscall->{$key}[0] ],
			[ $flat->{$caller}{$sortkey}{$key}[1], $thiscall->{$key}[1] ] ]);
	    }
	    push (@{$row->{CALLERS}}, $callrow);
	}

	# row
	push (@{$row->{SYM}}, $flat->{$sym}{RANK});
	push (@{$row->{SYM}}, $dump->{SYMS}{$sym}{NAME});
	push (@{$row->{SYM}}, $dump->{SYMS}{$sym}{LIB});
	push (@{$row->{SYM}}, map { $flat->{$sym}{$sortkey}{$_} } @keyorder);

	# children
	foreach my $callee (@children)
	{
	    my $thiscall = $flat->{$sym}{CALLS}{$callee};
	    my $callrow = [ $flat->{$callee}{RANK},
			    $dump->{SYMS}{$callee}{NAME},
			    $dump->{SYMS}{$callee}{LIB} ];
	    foreach my $key (@keyorder)
	    {
		push (@$callrow,
		      [ [ $flat->{$callee}{CUM_KEY}{$key}[0], $thiscall->{$key}[0] ],
			[ $flat->{$callee}{$sortkey}{$key}[1], $thiscall->{$key}[1] ] ]);
	    }

	    push (@{$row->{CALLS}}, $callrow);
	}
    }

    if ($output eq 'text')
    {
        print "counters: ", join (", ", @keyorder), "\n";
	foreach my $entry (@table)
	{
	    my ($rank, $name, $lib, @keys);
	    print "\n", "-" x 70, "\n";
	    foreach my $caller (@{$entry->{CALLERS}})
	    {
		($rank, $name, $lib, @keys) = @$caller;
		print join("\t", "", map { "$_->[0]/$_->[1]" } map { @$_ } @keys);
		print "\t@{[&symname ($name)]} [$rank]";
		print " ($lib)" if $showlibs;
		print "\n";
	    }

	    ($rank, $name, $lib, @keys) = @{$entry->{SYM}};
	    print join("\t", "[$rank]", map { @$_ } @keys);
	    print "\t@{[&symname ($name)]}";
	    print " ($lib)" if $showlibs;
	    print "\n";

	    foreach my $callee (@{$entry->{CALLS}})
	    {
		($rank, $name, $lib, @keys) = @$callee;
		print join("\t", "", map { "$_->[0]/$_->[1]" } map { @$_ } @keys);
		print "\t@{[&symname ($name)]} [$rank]";
		print " ($lib)" if $showlibs;
		print "\n";
	    }
	}
    }
    elsif ($output eq 'html')
    {
	sub htmlcounter {
	    my ($span, $value, $count) = @_;
	    my $spanarg = $span == 1 ? "" : " colspan=\"$span\"";
	    print "    <td$spanarg>$value</td>\n";
	    print "    <td$spanarg>$count</td>\n";
	}
	    
	sub htmlrow {
	    my ($keyorder, $type, $rank, $name, $lib, @keys) = @_;
	    print "  <tr>\n";
	    if ($type eq 0) {
		print "    <td><a name=\"R$rank\">[$rank]</a></td>\n";
	    } else {
		print "    <td>&nbsp;</td>\n";
	    }
	    foreach my $key (@$keyorder) {
		my $val = shift(@keys);
		if (ref($val) eq 'ARRAY' and ref($val->[0]) eq 'ARRAY') {
		    # caller/call syntax
		    &htmlcounter (1, $val->[0][0], $val->[1][0]);
		    &htmlcounter (1, $val->[0][1], $val->[1][1]);
		} else {
		    # symbol syntax
		    &htmlcounter (2, @$val);
		}
	    }
	    $name = &symname ($name);
	    $name =~ s/&/&amp;/g; $name =~ s/</&lt;/g; $name =~ s/>/&gt;/g;
	    print "    <td><a href=\"#R$rank\">$name</a>";
	    if ($type eq 0) {
		print "</td>\n";
	    } else {
		print "&nbsp;[$rank]</td>\n";
	    }
	    $lib =~ s/&/&amp;/g; $lib =~ s/</&lt;/g; $lib =~ s/>/&gt;/g;
	    print "    <td>$lib</td>\n" if $showlibs;
	    print "    <td>&nbsp;</td>\n" if ! $showlibs;
	    print "  </tr>\n";
	}

        print "<table width='100%' border='0'>\n";
	print "  <tr>\n";
	print "    <th>Order</th>\n";
	foreach my $key (@keyorder) {
	    print "    <th colspan='4'>$key</td>\n";
	}
	print "    <th>Symbol</th>\n";
	print "    <th>Library</th>\n";
	print "  </tr>\n";

	foreach my $entry (@table)
	{
	    print "  <tr><td colspan='" . (scalar(@keyorder) * 4 + 3) . "'><hr /></tr>\n";
	    foreach my $caller (@{$entry->{CALLERS}}) {
		&htmlrow (\@keyorder, 1, @$caller);
	    }

	    my $rank = $entry->{SYM}[0];
	    &htmlrow (\@keyorder, 0, @{$entry->{SYM}});

	    foreach my $callee (@{$entry->{CALLS}}) {
		&htmlrow (\@keyorder, 1, @$callee);
	    }
	}
        print "</table>\n";
    }
    elsif ($output eq 'xml')
    {
	sub xmlcounter {
	    my ($prefix, $type, $key, $value, $count) = @_;
	    print "    $prefix<value type=\"$type\" counter=\"$key\" ",
		  "value=\"$value\" count=\"$count\"/>\n";
	}
	    
	sub xmlrow {
	    my ($keyorder, $prefix, $rank, $name, $lib, @keys) = @_;
	    my $keytype = $sortkey eq 'CUM_KEY' ? "cumulative" : "self";
	    print "  $prefix<entry rank=\"$rank\" symbol=\"$name\" module=\"$lib\">\n";
	    foreach my $key (@$keyorder) {
		my $val = shift(@keys);
		if (ref($val) eq 'ARRAY' and ref($val->[0]) eq 'ARRAY') {
		    # caller/call syntax
		    &xmlcounter ($prefix, "cumulative", $key, $val->[0][0], $val->[1][0]);
		    &xmlcounter ($prefix, "call$keytype", $key, $val->[0][1], $val->[1][1]);
		} else {
		    # symbol syntax
		    &xmlcounter ($prefix, $keytype, $key, @$val);
		}
	    }
	}

        print "<igprof-analysis>\n";
	foreach my $key (@keyorder) {
	    print "  <counter name=\"$key\"/>\n";
	}
	foreach my $entry (@table)
	{
	    &xmlrow (\@keyorder, "", @{$entry->{SYM}});
	    foreach my $caller (@{$entry->{CALLERS}}) {
		&xmlrow (\@keyorder, "  ", @$caller);
	        print "       </entry>\n";
	    }
	    foreach my $callee (@{$entry->{CALLS}}) {
		&xmlrow (\@keyorder, "  ", @$callee);
	        print "       </entry>\n";
	    }
	    print "   </entry>\n";
	}
        print "</igprof-analysis>\n";
    }
}

sub accumulate
{
    my ($parent, $node) = @_;

    # Initialise missing counters
    foreach my $counter (@allkeys)
    {
	$node->{COUNTERS}{$counter} ||= [ 0, 0 ];
    }

    # Initialise cumulative counters to self values
    my @counters = keys %{$node->{COUNTERS}};
    foreach my $counter (@counters)
    {
	my $cumname = "${counter}_CUM";
	$node->{COUNTERS}{$cumname} = [ @{$node->{COUNTERS}{$counter}} ];
    }

    # Process children
    foreach my $kid (@{$node->{CHILDREN}}) {
	&accumulate ($node, $kid);
    }

    # Accumulate parent cumulative counts
    foreach my $counter (grep ($_ !~ /_CUM$/, keys %{$node->{COUNTERS}}))
    {
	my $cumname = "${counter}_CUM";
	my $cumval = $node->{COUNTERS}{$cumname};

	defined $cumval or die;
	$parent->{COUNTERS}{$counter} ||= [ 0, 0 ];
	$parent->{COUNTERS}{$cumname} ||= [ 0, 0 ];
	if ($counter =~ /_MAX$/)
	{
	    $parent->{COUNTERS}{$cumname}[0] = $cumval->[0]
	        if $parent->{COUNTERS}{$cumname}[0] < $cumval->[0];
	    $parent->{COUNTERS}{$cumname}[1] += $cumval->[1];
	}
	else
	{
	    $parent->{COUNTERS}{$cumname}[0] += $cumval->[0];
	    $parent->{COUNTERS}{$cumname}[1] += $cumval->[1];
        }
    }
}

sub suppressions
{
    my ($syms, $parent, $node) = @_;

    # Apply counts of a filtered node to the parent
    if (grep ($_ eq $syms->{$node->{SYMADDR}}{NAME}, @filters))
    {
        foreach my $counter (grep ($_ !~ /_CUM$/, keys %{$node->{COUNTERS}}))
	{
	    my $name = $counter;
	    my $cumname = "${counter}_CUM";
	    my $cumval = $node->{COUNTERS}{$cumname};

	    defined $cumval or die;
	    defined $parent->{COUNTERS}{$name} or die;
	    if ($name =~ /_MAX$/)
	    {
		$parent->{COUNTERS}{$name}[0] = $cumval->[0]
		    if $parent->{COUNTERS}{$name}[0] < $cumval->[0];
		$parent->{COUNTERS}{$name}[1] += $cumval->[1];
	    }
	    else
	    {
		$parent->{COUNTERS}{$name}[0] += $cumval->[0];
		$parent->{COUNTERS}{$name}[1] += $cumval->[1];
	    }
        }

	@{$parent->{CHILDREN}} = grep ($_ ne $node, @{$parent->{CHILDREN}});
    }

    # Process children
    my @kids = @{$node->{CHILDREN}};
    foreach my $kid (@kids) {
	&suppressions ($syms, $node, $kid);
    }
}

sub summarise 
{
    my ($flat, $sym) = @_;
    foreach my $key (@keys) {
	my ($sval, $cval);
	if ($key =~ /_MAX$/) {
	    $sval = $flat->{$sym}{SELF}{MAX}{$key};
	    $cval = $flat->{$sym}{CUM}{MAX}{$key};
	} else {
	    $sval = $flat->{$sym}{SELF}{SUM}{$key};
	    $cval = $flat->{$sym}{CUM}{SUM}{$key};
	}
	$flat->{$sym}{SELF_KEY}{$key} = [ @$sval ];
	$flat->{$sym}{CUM_KEY}{$key} = [ @$cval ];
    }

    return 0;
}

sub cmpnodekey
{
    my ($flat, $which, $keys, $a, $b) = @_;
    foreach my $key (@$keys) {
	my $aval = $flat->{$a}{$which}{$key}[0];
	my $bval = $flat->{$b}{$which}{$key}[0];
	$aval = -1 if ! defined ($aval);
	$bval = -1 if ! defined ($bval);
	my $diff = -1 * $order * ($aval <=> $bval);
	return $diff if $diff;
    }

    return 0;
}

sub callcheck
{
    # check if a calls b; return 1 if it does (= should come before)
    my ($flat, $a, $b, $seen) = @_;
    $seen->{$a} = 1;
    foreach my $callee (keys %{$flat->{$a}{CALLS}}) {
	next if $seen->{$callee} || $callee eq $a;
	return -1 if $b eq $callee;
	return -1 if &callcheck ($flat, $callee, $b, $seen) < 0;
    }
    return 0;
}

sub cmpcallers
{
    my ($flat, $a, $b) = @_;
    # If a calls b, order it first
    my $acall = &callcheck ($flat, $a, $b, {});
    my $bcall = &callcheck ($flat, $b, $a, {});
    return $acall <=> $bcall;
}

sub cmpnodes
{
    my ($flat, $keys, $a, $b) = @_;
    return &cmpnodekey ($flat, $sortkey, $keys, $a, $b)
        || &cmpnodekey ($flat, "CUM_KEY", $keys, $a, $b)
	|| &cmpcallers ($flat, $a, $b)
	|| (eval ($a) <=> eval ($b));
}

sub analysenode
{
    my ($parent, $node, $result) = @_;
    my $sym = $node->{SYMADDR};
    my $symnode = ($result->{$sym} ||= {});

    # Add values for all requested counters.  Note that all counters exist.
    foreach my $counter (keys %{$node->{COUNTERS}}) {
	my ($part, $name, $val) = ("SELF", $counter, $node->{COUNTERS}{$counter});
	if ($name =~ /(.*)_CUM$/) {
	    $part = "CUM"; $name = "$1";
	}

	if (grep ($name eq $_, @keys))
	{
	    if ($parent)
	    {
	        $symnode->{CALLERS}{$parent} = 1;
		$result->{$parent}{CALLS}{$sym}{$counter} ||= [ 0, 0 ];
		$result->{$parent}{CALLS}{$sym}{$counter}[0] += $val->[0];
		$result->{$parent}{CALLS}{$sym}{$counter}[1]++;
	    }

            $symnode->{$part}{MAX}{$name} ||= [ 0, 0 ];
            $symnode->{$part}{MAX}{$name}[0] = $val->[0]
		if ($symnode->{$part}{MAX}{$name}[0] < $val->[0]);
            $symnode->{$part}{MAX}{$name}[1]++;

            $symnode->{$part}{SUM}{$name} ||= [ 0, 0 ];
            $symnode->{$part}{SUM}{$name}[0] += $val->[0];
            $symnode->{$part}{SUM}{$name}[1]++;
	}
    }

    # Analyse children
    foreach my $kid (@{$node->{CHILDREN}}) {
	&analysenode ($sym, $kid, $result);
    }
}

sub usage
{
    print STDERR "igprof-analyse [-r/--report KEY[,KEY]...]\n",
    		 "  [-s/--sort KEY[,KEY]...] [-o/--order ORDER]\n",
		 "  [-f/--filter FILE] [-F/--no-filter]\n",
		 "  { [-e/--self] | [-c/--cumulative] }\n",
		 "  { [-x/--xml] | [-h/--html] | [-t/--text]\n",
		 "  [--] [FILE]...\n";
}

while ($#ARGV != 0)
{
    if ($ARGV[0] eq '--help')
    { &usage(); exit (1); }
    elsif ($ARGV[0] eq '--report' || $ARGV[0] eq '-r')
    { @keys = split(',', $ARGV[1]); shift (@ARGV); shift (@ARGV); }
    elsif ($ARGV[0] eq '--sort' || $ARGV[0] eq '-s')
    { @sort = split(',', $ARGV[1]); shift (@ARGV); shift (@ARGV); }
    elsif ($ARGV[0] eq '--order' || $ARGV[0] eq '-o')
    { $order = $ARGV[1] eq 'ascending' ? -1 : 1; shift (@ARGV); shift (@ARGV); }
    elsif ($ARGV[0] eq '--filter' || $ARGV[0] eq '-f')
    { push (@filterfiles, $ARGV[1]); shift (@ARGV); shift (@ARGV); }
    elsif ($ARGV[0] eq '--no-filter' || $ARGV[0] eq '-F')
    { @builtinfilter = (); shift (@ARGV); }
    elsif ($ARGV[0] eq '--self' || $ARGV[0] eq '-e')
    { $sortkey = "SELF_KEY"; shift (@ARGV); }
    elsif ($ARGV[0] eq '--cumulative' || $ARGV[0] eq '-c')
    { $sortkey = "CUM_KEY"; shift (@ARGV); }
    elsif ($ARGV[0] eq '--libs' || $ARGV[0] eq '-l')
    { $showlibs = 1; shift (@ARGV); }
    elsif ($ARGV[0] eq '--xml' || $ARGV[0] eq '-x')
    { $output = "xml"; shift (@ARGV); }
    elsif ($ARGV[0] eq '--html' || $ARGV[0] eq '-h')
    { $output = "html"; shift (@ARGV); }
    elsif ($ARGV[0] eq '--text' || $ARGV[0] eq '-t')
    { $output = "text"; shift (@ARGV); }
    elsif ($ARGV[0] eq '--demangle' || $ARGV[0] eq '-d')
    { $demangle = 1; shift (@ARGV); }
    elsif ($ARGV[0] eq '--')
    { last; }
    elsif ($ARGV[0] =~ /^-/)
    { print STDERR "unknown option $ARGV[0]"; &usage(); exit (1); }
    else
    { last; }
}

# read in lists of filter symbols
@filters = @builtinfilter;
foreach my $file (@filterfiles)
{
    open (FILTER, "< $file") || die "$file: $!\n";
    while (<FILTER>)
    {
  	chomp;
	push (@filters, split(/s+/, $_));
    }
    close (FILTER);
}

foreach my $file (@ARGV)
{
    my $prof = &readDump ($file);
    @allkeys = &keysof ($prof);
    foreach my $key (@sort, @keys) {
	push (@allkeys, $key) if ! grep ($_ eq $key, @allkeys);
    }
    @keys = @allkeys if ! scalar @keys;
    &analyse ($prof);
}
